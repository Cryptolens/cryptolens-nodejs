const helpers = require('../internal/HelperMethods.js');
const { execSync } = require("child_process");
const crypto = require('crypto');


module.exports = class Helpers {

    /**
     * Save the license as a string that can later be read by LoadFromString.
     * @param {object} licenseKey The license key object to serialize.
     */
    static SaveAsString(licenseKey) {
        if (licenseKey.RawResponse) {
            return JSON.stringify(licenseKey.RawResponse);
        }
        console.warn("The license key does not have a raw response field.");
        return null;
    }

    /**
     * Loads a license from a string generated by SaveAsString.
     * Note: if an error occurs, null will be returned. An error can occur
     * if the license string has been tampered with or if the public key is
     * incorrectly formatted.
     * @param {string} rsaPubKey The RSA Public key
     * @param {string} string
     * @param {number} SignatureExpirationInterval If the license key was signed,
     * this method will check so that no more than "signatureExpirationInterval"
     * days have passed since the last activation.
     */
    static LoadFromString(rsaPubKey, string, signatureExpirationInterval = 0) {
        try {
            const response = JSON.parse(string);

            if (helpers.VerifySignature(response, rsaPubKey)) {
                const licenseKey = JSON.parse(Buffer.from(helpers.GetValueCaseInsensitive(response,"licenseKey"), 'base64').toString("utf-8"));
                const signed = new Date(licenseKey.SignDate * 1000);
                const exp = new Date(signed.getFullYear(), signed.getMonth(), signed.getDate() + signatureExpirationInterval);
                if (signatureExpirationInterval > 0 && new Date() > exp) {
                    console.warn("The license has expired.");
                    return null;
                }
                licenseKey.RawResponse = response;
                return licenseKey;
            }
            return null;
        } catch (error) {
            return null;
        }
    }


    /**
     * Returns a machine code of the current device.
     */
    static GetMachineCode() {

        let res = "";

        if (process.platform === "win32") {
            res = (execSync('cmd /c powershell.exe -Command "(Get-CimInstance -Class Win32_ComputerSystemProduct).UUID"', { encoding: 'utf8' }));
            res = res.substring(res.indexOf("UUID")).trim();
        } else if (process.platform === "linux") {
            res = (execSync("findmnt --output=UUID --noheadings --target=/boot", { encoding: 'utf8' }));
        } else if (process.platform === "darwin") {
            res = (execSync("system_profiler SPHardwareDataType | awk '/UUID/ { print $3; }'", { encoding: 'utf8' }));
        }

        return crypto.createHash('sha256').update(res).digest('hex');
    }

    /**
     * Compute a shorter version of the machine code that is more easily to type for end users.
     * Note, please use the corresponding Helpers.IsOnRightMachineShort method instead, when verifying
     * if a license has been activated on this machine.
     */
    static GetMachineCodeShort() {
        return this.GetMachineCode().slice(0, 20);
    }

    /**
     * Check if the current license has expired.
     * @param licenseKey a license key object.
     * @return True if it has expired and false otherwise.
     */
    static HasExpired(licenseKey) {
        if (licenseKey == null) {
            return false;
        }

        let unixTime = new Date() / 1000;

        if (licenseKey.Expires < unixTime) {
            return true;
        }

        return false;
    }

    /**
     * Check if the current license has not expired.
     * @param licenseKey a license key object.
     * @return True if it has not expired and false otherwise.
     */
    static HasNotExpired(licenseKey) {
        return !Helpers.HasExpired(licenseKey);
    }


    /**
     * Check if the license has a certain feature enabled (i.e. set to true). If the feature parameter is an integer, then
     * this method will check against the 8 built in feature flags (F1..F8). If feature parameter is a string, the method
     * will use a built in data object to determine if a certain feature exists. Below is more information about that:
     * 
     * <strong>Formatting: </strong> The name of the data object should be 'cryptolens_features' and it should be structured as a JSON array.
     *   
     * For example, <pre>["f1", "f2"]</pre><p>means f1 and f2 are true. You can also have feature bundling, eg. <pre>["f1", ["f2",["voice","image"]]]</pre>
     * which means that f1 and f2 are true, as well as f2.voice and f2.image. You can set any depth, eg. you can have
     * <pre>["f1", ["f2",[["voice",["all"]], "image"]]]</pre> means f2.voice.all is true as well as f2.voice and f2.
     * The dots symbol is used to specify the "sub-features". 
        
     * Read more here: https://help.cryptolens.io/web-interface/feature-templates
     * 
     * @param licenseKey a license key object.
     * @param feature The feature, eg 1 to 8.
     * @return If the feature is set to true, true is returned and false otherwise.
     */
    static HasFeature(licenseKey, feature) {

        if (licenseKey == null) {
            return false;
        }

        if (!isNaN(feature)) {
            if (feature === 1 && licenseKey.F1)
            return true;
            if (feature === 2 && licenseKey.F2)
                return true;
            if (feature === 3 && licenseKey.F3)
                return true;
            if (feature === 4 && licenseKey.F4)
                return true;
            if (feature === 5 && licenseKey.F5)
                return true;
            if (feature === 6 && licenseKey.F6)
                return true;
            if (feature === 7 && licenseKey.F7)
                return true;
            if (feature === 8 && licenseKey.F8)
                return true;

            return false;
        }

        if (!licenseKey["DataObjects"]) {
            return false;
        }
        
        var features = null;

        for(const dobj of licenseKey["DataObjects"] ) {
            if(dobj["Name"] == 'cryptolens_features') {
                features = dobj["StringValue"];
                break;
            }
        }

        if (features == null || feature.trim() == "") {
            return false;
        }

        var array = JSON.parse(features);

        var featurePath = feature.split("\.");

        var found = false;

        for (let i = 0; i < featurePath.length; i++) {
            found = false;

            var index = -1;

            for (let j = 0; j < array.length; j++) {

                if (!Array.isArray(array[j]) && array[j]==featurePath[i]) {
                    found = true;
                    break;
                } else if(Array.isArray(array[j]) && array[j][0] == featurePath[i]) {
                    found = true;
                    index = j;
                    break;
                }   
            }
            if(!found) {
                return false;
            }

            if(i+1 < featurePath.length && index != -1) {
                array = array[index][1];
            }
            
        }

        if(!found){
            return false;
        }

        return true;
    }



    /**
      * Check if the device is registered with the license key.
      * @param license The license key object.
      * @param isFloatingLicense If this is a floating license, this parameter has to be set to true.
      *                          You can enable floating licenses by setting @see ActivateModel.FloatingTimeInterval.
      * @param allowOverdraft If floating licensing is enabled with overdraft, this parameter should be set to true.
      *                       You can enable overdraft by setting ActivateModel.MaxOverdraft" to a value greater than 0.
      *
      * @return True if the license is registered with this machine and False otherwise.
      */
    static IsOnRightMachine(license, isFloatingLicense, allowOverdraft) {
        return this.IsOnRightMachineCustom(license, this.GetMachineCode(), isFloatingLicense, allowOverdraft);
    }

    /**
      * Check if the device is registered with the license key. This method uses a shorter version of the machine code,
      * computed using Helpers.GetMachineCodeShort.
      * @param license The license key object.
      * @param isFloatingLicense If this is a floating license, this parameter has to be set to true.
      *                          You can enable floating licenses by setting @see ActivateModel.FloatingTimeInterval.
      * @param allowOverdraft If floating licensing is enabled with overdraft, this parameter should be set to true.
      *                       You can enable overdraft by setting ActivateModel.MaxOverdraft" to a value greater than 0.
      *
      * @return True if the license is registered with this machine and False otherwise.
      */
    static IsOnRightMachineShort(license, isFloatingLicense, allowOverdraft) {
        return this.IsOnRightMachineCustom(license, this.GetMachineCodeShort(), isFloatingLicense, allowOverdraft);
    }

    /**
      * Check if the device is registered with the license key. This method allows you to pass in a custom machine code.
      * @param license The license key object.
      * @param machineCode The machine code of the current device.
      * @param isFloatingLicense If this is a floating license, this parameter has to be set to true.
      *                          You can enable floating licenses by setting @see ActivateModel.FloatingTimeInterval.
      * @param allowOverdraft If floating licensing is enabled with overdraft, this parameter should be set to true.
      *                       You can enable overdraft by setting ActivateModel.MaxOverdraft" to a value greater than 0.
      *
      * @return True if the license is registered with this machine and False otherwise.
      */
    static IsOnRightMachineCustom(license, machineCode, isFloatingLicense, allowOverdraft) {

        if (license == null || license.ActivatedMachines == null) {
            return false;
        }

        if (machineCode == null) {
            machineCode = this.GetMachineCode();
        }

        let res = false;

        console.log(isFloatingLicense);

        if (isFloatingLicense) {
            console.log("floating");
            license.ActivatedMachines.forEach(machine => {
                if (machine.Mid.length >= 9 && machine.Mid.substring(9) === machineCode ||
                    allowOverdraft && machine.Mid.length >= 19 && machine.Mid.substring(19) === machineCode) {
                    res = true;
                }
            })
        } else {

            license.ActivatedMachines.forEach(machine => {
                if (machine.Mid === machineCode) {
                    res = true;
                }
            });
        }
        return res;
    }
}
